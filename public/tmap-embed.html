<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tmap Embed</title>
  <style>
    html,
    body,
    #map {
      height: 100%;
      margin: 0;
      padding: 0;
    }
  </style>
  <script>
    // Tmap SDK는 내부적으로 document.write를 사용하므로, 반드시 파서 차단 방식으로 삽입해야 합니다.
    (function () {
      try {
        var params = new URLSearchParams(location.search);
        var key = params.get('appKey') || '';
        document.write('<script src="https://apis.openapi.sk.com/tmap/jsv2?version=1&appKey=' + key + '"><\\/script>');
      } catch (e) {
        console.error('Failed to inject Tmap SDK:', e);
      }
    })();
  </script>
</head>

<body>
  <div id="map"></div>
  <script>
    var map = null;
    var polylines = [];
    var markers = [];
    var infoWindows = [];
    var segmentPolylines = [];

    function clearMap() {
      polylines.forEach(function (p) { p.setMap(null); });
      segmentPolylines.forEach(function (p) { p.setMap(null); });
      markers.forEach(function (m) { m.setMap(null); });
      infoWindows.forEach(function (w) { try { w.setMap(null); } catch (e) { } });
      infoWindows = [];
      polylines = []; markers = []; segmentPolylines = [];
    }

    function drawRoute(routeData) {
      if (!routeData) return;
      var features = routeData.features || [];
      var T = window.Tmapv2;
      clearMap();
      var bounds = new T.LatLngBounds();
      var waypoints = (routeData.waypoints || []).map(function (w) { return new T.LatLng(w.latitude, w.longitude); });

      // 세그먼트 메타 (optional)
      var segmentSummary = routeData.segmentSummary || [];

      // 경로 그리기
      for (var idx = 0; idx < features.length; idx++) {
        var feature = features[idx];
        var coords = feature && feature.geometry && feature.geometry.coordinates;
        if (!coords || !coords.length) continue;
        var flat = Array.isArray(coords[0][0]) ? coords.flat(1) : coords;
        var path = flat.map(function (c) { return new T.LatLng(c[1], c[0]); });
        if (path.length === 0) continue;
        polylines.push(new T.Polyline({ path: path, strokeColor: '#FF1744', strokeWeight: 5, map: map }));
        for (var k = 0; k < path.length; k++) { bounds.extend(path[k]); }
      }

      // 경로를 세그먼트 단위로 강조 가능한 라인으로 다시 그림 (출발→1, 1→2, ...)
      try {
        var wp = routeData.waypoints || [];
        for (var si = 0; si < wp.length - 1; si++) {
          var seg = features.filter(function (f) { return f.properties && f.properties.segmentIndex === si; });
          var segCoords = [];
          seg.forEach(function (f) {
            var coords = f.geometry && f.geometry.coordinates || [];
            var flat = Array.isArray(coords[0][0]) ? coords.flat(1) : coords;
            flat.forEach(function (c) { segCoords.push(new T.LatLng(c[1], c[0])); });
          });
          if (segCoords.length === 0) continue;
          var hue = 210 + si * 20;
          var color = 'hsl(' + hue + ',85%,55%)';
          var pl = new T.Polyline({ path: segCoords, strokeColor: color, strokeOpacity: 0.9, strokeWeight: 6, map: map });
          segmentPolylines.push(pl);

          // hover 효과 및 미니 배지
          (function (index, line) {
            var mid = segCoords[Math.floor(segCoords.length / 2)];
            var meta = segmentSummary[index] || {};
            var badgeHtml = '<div style="background:rgba(0,0,0,0.75);color:#fff;padding:4px 8px;border-radius:8px;font-size:12px;box-shadow:0 2px 8px rgba(0,0,0,.25);white-space:nowrap">' +
              (meta.distM ? (meta.distM / 1000).toFixed(1) + 'km · ' : '') + (meta.timeSec ? Math.round(meta.timeSec / 60) + '분' : '') +
              '</div>';
            var badge = new T.InfoWindow({ position: mid, content: badgeHtml, type: 2 });
            T.Event.addListener(line, 'mouseover', function () { line.setStrokeWeight(9); badge.setMap(map); });
            T.Event.addListener(line, 'mouseout', function () { line.setStrokeWeight(6); badge.setMap(null); });
            T.Event.addListener(line, 'click', function () { badge.setMap(map); });
          })(si, pl);
        }
      } catch (e) { console.warn('Segment draw failed', e); }

      // 개선된 핀 렌더링 - 새로운 속성들 처리
      var waypointData = routeData.waypoints || [];
      for (var i = 0; i < waypointData.length; i++) {
        var waypoint = waypointData[i];
        // lat/lng 속성 사용 (TmapMainMap에서 전달하는 속성명)
        var position = new T.LatLng(waypoint.lat, waypoint.lng);

        // 새로운 속성들 확인
        var icon = waypoint.icon || '📍';
        var color = waypoint.color || '#3B82F6';
        var label = waypoint.label || (i + 1);
        var priority = waypoint.priority || 1;

        // 아이콘과 색상에 따른 배경색 결정
        var backgroundColor;
        var textColor = '#FFFFFF';

        if (icon === '🚀') {
          backgroundColor = '#10B981'; // 출발지 - 초록색
        } else if (icon === '🎯') {
          backgroundColor = '#EF4444'; // 도착지 - 빨간색
        } else if (icon === '📍') {
          if (i === 0) {
            backgroundColor = '#3B82F6'; // 첫 번째 경유지 - 파란색
          } else {
            backgroundColor = '#8B5CF6'; // 중간 경유지 - 보라색
          }
        } else {
          backgroundColor = color; // 기본 색상
        }

        // 핀 내용 생성
        var content = '<div style="' +
          'background:' + backgroundColor + ';' +
          'color:' + textColor + ';' +
          'border-radius:12px;' +
          'padding:4px 8px;' +
          'font-size:14px;' +
          'font-weight:bold;' +
          'box-shadow:0 2px 8px rgba(0,0,0,0.3);' +
          'border:2px solid white;' +
          'min-width:24px;' +
          'text-align:center;' +
          'display:flex;' +
          'align-items:center;' +
          'justify-content:center;' +
          'gap:2px;' +
          '">' +
          '<span style="font-size:12px;">' + icon + '</span>' +
          '<span>' + label + '</span>' +
          '</div>';

        infoWindows.push(new T.InfoWindow({
          position: position,
          content: content,
          type: 2,
          map: map
        }));

        // 호버 툴팁 (주소/라벨)
        (function (wp, pos) {
          var tooltipHtml = '<div style="background:#111;color:#fff;padding:6px 8px;border-radius:8px;font-size:12px;box-shadow:0 2px 8px rgba(0,0,0,.25);white-space:nowrap">' +
            (wp.address ? wp.address : '') + (wp.label ? ' · ' + wp.label : '') +
            '</div>';
          var tip = new T.InfoWindow({ position: pos, content: tooltipHtml, type: 2 });
          var marker = new T.Marker({ position: pos, icon: new T.IconHtml('<div style="width:14px;height:14px;opacity:0"></div>') });
          marker.setMap(map);
          markers.push(marker);
          T.Event.addListener(marker, 'mouseover', function () { tip.setMap(map); });
          T.Event.addListener(marker, 'mouseout', function () { tip.setMap(null); });
          T.Event.addListener(marker, 'click', function () { tip.setMap(map); });
        })(waypoint, position);

        bounds.extend(position);
      }

      // 경로 영역으로 자동 맞춤
      try {
        if (bounds && typeof bounds.isEmpty === 'function' && !bounds.isEmpty()) {
          map.fitBounds(bounds, 30);
        }
      } catch (e) {
        console.error('Bounds fitting error:', e);
      }
    }

    function ensureMap(center) {
      if (map || !window.Tmapv2) return;
      var T = window.Tmapv2;
      var c = center || { lat: 37.566535, lng: 126.9779692 };
      map = new T.Map(document.getElementById('map'), {
        center: new T.LatLng(c.lat, c.lng),
        width: '100%',
        height: '100%',
        zoom: 14,
        zoomControl: true,
        scrollwheel: true
      });
    }

    window.addEventListener('message', function (ev) {
      try {
        var data = ev.data || {};
        if (data.type === 'init') {
          ensureMap(data.center);
        } else if (data.type === 'route') {
          ensureMap(data.center);
          drawRoute(data.routeData);
        }
      } catch (e) { console.error(e); }
    });

    // 초기 로드 시 맵만 준비 시도 (SDK가 이미 로드된 경우)
    if (window.Tmapv2) ensureMap();
  </script>
</body>

</html>