{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서 (PRD)\n\n## 1. 개요\n“옹고잉 최적동선·견적 프로그램”은 사륜차량 기반 물류 서비스를 운영하는 기업이 배송 동선을 최적화하고, 옹고잉 요금제를 기반으로 합리적 견적안을 신속히 생성하도록 돕는 웹·모바일 솔루션이다. 이를 통해 배송 효율 증대, 운영비 절감, 견적 작성 시간 단축을 달성한다.\n\n## 2. 문제 정의\n- 현재 배송 동선은 수작업이나 단순 네비게이션으로 계획되어 비효율 발생  \n- 실시간 교통정보 반영 부족으로 도착시간 예측 신뢰도가 낮음  \n- 복잡한 제약조건(차종, 적재중량, 작업시간 등)을 반영한 자동 배차 도구 부재  \n- 견적 산출 시 엑셀·수기 계산에 의존해 오류 및 시간이 과다 소요  \n\n## 3. 목표 및 목적\n- 1차 목표: 배송 동선 자동 최적화 및 견적 자동화  \n- 2차 목표: 운영 데이터 기반 비용·시간 절감 인사이트 제공  \n- 성공 지표  \n  - 평균 배차/견적 소요시간 70% 감소  \n  - 예상 도착시간 오차 ±5분 이내 90% 달성  \n\n  - 고객사 견적 전환율 30% 이상\n\n## 4. 대상 사용자\n### 주요 사용자\n- 옹고잉 팀원: 다수 배송원과 배송지를 효율적으로 관리하고 신속한 배차·견적 처리가 필요\n- 고객사(화주) 담당자 및 예비 고객사: 옹고잉 홈페이지 임베딩 후 자사 물류비 예측 및 견적 시스템 활용 의향이 높음\n### 부차 사용자\n- 고객사 담당자: 옹고잉 홈페이지 ‘견적산출기’로 자사 물류비 예측\n- 옹고잉 경영진: 운영 KPI 모니터링\n\n## 5. 사용자 스토리\n- 물류 운영팀으로서 여러 배송원에게 최적 동선을 자동 배정해 인건비를 절감하고 싶다.  \n- (향후) 배송 기사로서 내 배송 순서·예상 도착시간을 확인해 지연을 줄이고 싶다.  \n- 고객사 담당자로서 물류 조건을 입력해 즉시 견적서를 받아보고 예산을 확보하고 싶다.  \n\n\n## 6. 기능 요구사항\n### 핵심 기능\n1. 최적배차\n   - n명의 배송원과 m개 배송지 입력 시 Tmap/Atlan 경로 API로 최단·최소시간 경로 산출\n   - 교통 실시간 반영, 적재용량·차종·작업시간 제약 고려\n   - 인수기준: 동일 입력 대비 3분 내 결과 표시, 기존 수작업 대비 총 이동거리 10% 이상 감소\n\n2. 시간 최적화(단일 기사)\n   - 기사 1명이 정해진 순서를 유지하거나 재정렬하여 최소 소요시간 계산\n   - 인수기준: 30개 지점 10초 내 결과, ETA 오차 ±5분\n\n3. 제약조건 모델러\n   - 차종(레이, 스타렉스), 적재중량·부피, 경유지 작업시간 입력 UI\n   - 제약조건 JSON 스키마 저장/불러오기 지원\n\n4. 견적 자동화\n    - 옹고잉 요금제(시간당, 단건 퀵, 건당 고정 요금제) 기반 비용 산정 로직 구현\n      - 시간당 요금제: 기본시간 + 시간당 가중치 요금 (예: 2시간 기본, 이후 시간당 10,000원)\n      - 단건 퀵 요금제: 단일 목적지 고정 요금 + 거리 추가 요금 (예: 10km까지 15,000원, 이후 km당 1,000원)\n      - 건당 요금제: 배송 건당 고정 요금 (예: 건당 8,000원)\n      - 차종별 가중치: 레이 1.0, 스타렉스 1.2 등\n    - 반응형 웹: 데스크톱·태블릿·모바일 최적화\n    - PWA 설치 지원 (iOS UX 제약사항 별도 고려)\n      - iOS Safari 전용 온보딩 화면에서 ‘홈에 추가’ 방법 안내\n      - iOS PWA 캐시 용량 50MB 제한 반영, 이미지 등 리소스 최소화\n      - 백그라운드/오프라인 기능 제한, 수동 새로고침 및 업데이트 안내 제공\n      - iOS 16.4 이상 푸시알림 지원, 권한 요청 UX 포함\n      - 비밀번호/생체인증, 일부 OS 기능(ARKit, Bluetooth 등) 미지원 안내\n   - 인수기준: 견적 생성 10초 이내, 계산 오류율 0.1% 이하\n\n5. 멀티 플랫폼 지원\n   - 반응형 웹: 데스크톱·태블릿·모바일 최적화\n   - PWA 설치 지원\n\n### 지원 기능\n- 다중 시나리오 저장/불러오기\n- 관리자 대시보드(사용 현황)\n\n## 7. 비기능 요구사항\n- 성능: API 응답 1초 이하, 동시에 2,000 세션 처리\n- 보안: OAuth 2.0, JWT, HTTPS, GDPR·개인정보보호법 준수\n- 사용성: 온보딩 5분 이내 학습, UI 접근성 WCAG AA\n- 확장성: 마이크로서비스 구조, 컨테이너 오토스케일\n- 데이터: 배송 기록, 견적 로그, 관리자 계정\n- MVP 단계에서는 고객사 정보만 최소화하여 저장, 불필요한 개인정보 수집 금지\n- 외부 API: SKT Tmap 다중경유지 API (실시간 교통정보, 최적 경로, 차종/적재 제약 반영)\n- 아키텍처: ISR(Incremental Static Regeneration) + Server Actions\n- 기타 Mapper’s Atlan API(백업용), Google/Apple 지도는 규제로 한국 내 부적합으로 사용하지 않음\n- Tmap 다중경유지(무료 이용 가능 시 우선 활용), 기타 무료 경로 API는 예비 검토\n- 백엔드: Supabase(PostgreSQL, Auth, Storage)\n- 배포: Vercel + Supabase Region ap-northeast-1\n- 외부 API: Tmap 다중경유지, Mapper’s Atlan API\n- 아키텍처: ISR(Incremental Static Regeneration) + Server Actions\n- 외부 API: Tmap 다중경유지(무료 이용 가능 시 우선 활용), 기타 무료 경로 API 검토\n- 3rd Party: PDFKit, ExcelJS, Mapbox GL(View)\n- 데이터: 배송 기록, 견적 로그, 관리자 계정 (향후 로그인/권한 모델 확장 예정)\n## 9. 성공 지표\n- 사용자 채택: MAU, 신규 견적 생성 수\n- 비즈니스: 견적→계약 전환율, 평균 배송비 절감률\n- 기술: API 오류율 <0.5%, P95 응답시간 <800ms\n\n## 10. 일정 및 마일스톤\n- Phase 1 (M+2): MVP—최적배차, 단일 기사 시간 최적화, 기초 견적\n- Phase 2 (M+4): 제약조건 모델러, PDF/Excel 견적서, 대시보드\n- Phase 3 (M+6): 실시간 위치 추적, 다국어, PWA, AI 예측 강화\n\n## 11. 위험 및 대응\n- API 요금 급증: 호출 캐싱, 경로 결과 캐시 TTL 관리  \n- 경로 정확도 부족: Tmap·Atlan 복수 알고리즘 비교, 수동 조정 UI  \n- 사용자 채택 저조: 무료 체험, 웨비나 교육, 내부 영업 팀 인센티브  \n- 데이터 보안: 정기 보안 점검, 침입탐지시스템 연동\n\n## 12. 향후 과제\n- AI 기반 수요 예측 후 차량·기사 자동 스케줄링\n- 화물 추적 IoT 기기 연동\n- SaaS 형태 해외 시장 진출 및 다국통화 결제\n- 머신러닝 기반 실시간 요금 조정(혼잡도 반영)\n\n",
      "writedAt": "2025-07-28T15:30:33.350Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  “옹고잉 스마트 물류 플랫폼”은 Next.js 기반 반응형 웹(PWA)과 Supabase 백엔드를 활용해 배송 루트 최적화, 제약조건 모델링, 자동 견적·배차 추천, 실시간 차량 위치 추적, 관리자 대시보드, 다국어 지원 기능을 제공. Tmap/Atlan 경로 API로 실시간 교통 반영, PDFKit·ExcelJS로 문서 출력, Mapbox GL로 지도 시각화를 구현.\n- **Core Technology Stack**  \n  Next.js 15, React, Tailwind CSS, Supabase(PostgreSQL/Auth/Storage), Tmap API, Atlan API, PDFKit, ExcelJS, Mapbox GL, Vercel 배포.\n- **Key Technical Objectives**  \n  · API 응답 시간 P95 < 800ms  \n  · 동시 2,000 세션 처리  \n  · 배차·견적 소요시간 70% 감소  \n  · ETA 오차 ±5분 이내 90% 달성  \n  · 실시간 차량 위치 갱신 지연 ≤ 15초  \n  · 다국어 UI 전환 시간 < 200ms\n- **Critical Technical Assumptions**  \n  · Tmap 무료 호출 한도 내 사용  \n  · Supabase Region ap-northeast-1 활용  \n  · Vercel ISR·Server Actions 지원  \n  · 고객사 브라우저 최신 버전 사용\n\n---\n\n## 2. Tech Stack\n\n| Category           | Technology / Library      | Reasoning                                       |\n| ------------------ | ------------------------- | ----------------------------------------------- |\n| 프론트엔드         | Next.js 15 + React        | ISR/Server Actions 기반 빠른 렌더링, PWA 지원, 다국어 지원 |\n| 스타일링           | Tailwind CSS              | 유연한 유틸리티 클래스, 빠른 UI 개발            |\n| 백엔드             | Supabase (Edge Functions) | Auth·DB·Storage 통합, 서버리스 확장성           |\n| 데이터베이스       | PostgreSQL (Supabase)     | 관계형 모델링, 복잡한 쿼리·제약조건 처리 최적   |\n| 인증·보안          | Supabase Auth (JWT, OAuth2) | GDPR·개인정보보호법 준수, 토큰 기반 보안       |\n| 경로 최적화 API    | Tmap API, Atlan API       | 실시간 교통반영, 복수 알고리즘 비교             |\n| 실시간 위치 추적   | Supabase Realtime         | 차량 위치 WebSocket 기반 실시간 구독            |\n| 지도 시각화        | Mapbox GL                 | 고성능 벡터 타일 지도, 인터랙티브 기능 지원     |\n| 문서 생성          | PDFKit, ExcelJS           | 서버사이드 PDF·엑셀 동적 생성                   |\n| 배포·호스팅         | Vercel                     | Next.js 최적화 배포, 글로벌 CDN                  |\n| CI/CD              | GitHub Actions            | 코드 푸시 시 자동 빌드·테스트·배포              |\n| 모니터링·로깅      | Vercel Analytics, Supabase Logs | 오류·성능 모니터링, 쿼리 로그                   |\n\n---\n\n## 3. System Architecture Design\n\n### Top-Level building blocks\n- **Frontend (Next.js + React + Tailwind)**  \n  · ISR 페이지, Server Actions  \n  · PWA 설치 지원, 반응형 UI  \n- **Backend (Supabase Edge Functions)**  \n  · 경로 최적화, 견적 계산 비즈니스 로직  \n  · Auth·Storage 제어  \n- **Database (PostgreSQL)**  \n  · 배송지·제약조건·견적 로그 테이블  \n  · 인덱스 기반 쿼리 최적화  \n- **External API Layer**  \n  · Tmap/Atlan 경로 호출 및 TTL 캐싱  \n- **Document Generator**  \n  · PDFKit/ExcelJS 모듈로 문서 동적 생성  \n- **Map Visualization**  \n  · Mapbox GL 클라이언트 컴포넌트\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n  Client[Frontend (Next.js)] -->|API 요청| Backend[Supabase Edge Functions]\n  Backend -->|CRUD| DB[PostgreSQL]\n  Backend -->|경로 요청| TmapAPI[Tmap/Atlan API]\n  Backend -->|문서 생성| DocGen[PDFKit/ExcelJS]\n  Client -->|지도 렌더링| Mapbox[Mapbox GL]\n```\n- 클라이언트는 Next.js API 경로로 배송·견적 요청 전송  \n- Edge Functions에서 DB 조회·경로 API 호출·계산 후 결과 반환  \n- 반환된 데이터로 클라이언트가 지도(Mapbox) 및 UI 업데이트  \n- 견적 요청 시 서버 사이드에서 PDFKit/ExcelJS로 문서 생성 후 다운로드\n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**  \n- **배차 도메인(dispatch)**: 최적경로 계산, Tmap/Atlan 연동  \n- **시간 최적화(time-optimizer)**: 단일 기사 루트 최소화 알고리즘  \n- **제약조건 모델러(constraints)**: JSON 스키마 저장·로드  \n- **견적 도메인(quote)**: 요금제 기반 비용 계산, 문서 출력  \n- **사용자관리(auth)**: 로그인·권한·세션 처리  \n- **대시보드(admin)**: 통계·사용 현황 조회\n\n**Universal File & Folder Structure**\n```\n/\n├── src/\n│   ├── pages/                 # Next.js 페이지\n│   ├── components/            # UI 컴포넌트\n│   ├── domains/\n│   │   ├── dispatch/          # 배차 관련 로직\n│   │   ├── time-optimizer/    # 단일 기사 최적화\n│   │   ├── constraints/       # 제약조건 모델러\n│   │   ├── quote/             # 견적 계산·문서\n│   │   ├── auth/              # 인증·사용자관리\n│   │   └── admin/             # 관리자 대시보드\n│   ├── libs/                  # API 클라이언트 래퍼\n│   ├── styles/                # Tailwind 설정·글로벌 스타일\n│   └── utils/                 # 공통 유틸리티 함수\n├── supabase/\n│   ├── functions/             # Edge Functions 소스\n│   └── migrations/            # DB 스키마 관리\n├── public/                    # 정적 자산\n├── vercel.json                # Vercel 설정\n└── package.json               # 의존성·스크립트\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: Next.js API Routes & Server Actions, REST/JSON  \n- **Database Interaction**: Supabase JS 클라이언트, 쿼리 캐싱·인덱스 활용  \n- **External Service Integration**: 경로 결과 TTL 캐싱, 재시도 로직, 장애 격리  \n- **Real-time Communication**: (향후) Supabase Realtime or WebSocket 구독  \n- **Data Synchronization**: 트랜잭션 적용, 견적 로그 이중 기록\n\n---\n\n## 4. Performance & Optimization Strategy\n- ISR & Server Actions 조합으로 페이지 로드 최적화  \n- 경로 API 결과 캐싱(TTL 기반)으로 호출 최소화  \n- DB 인덱스·파티셔닝으로 대량 데이터 조회 가속  \n- 코드 스플리팅, 이미지·지도 타일 lazy loading  \n\n---\n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP Implementation) – ~M+2\n- Core Infrastructure: Next.js 프로젝트, Supabase 초기 설정  \n- Essential Features: 최적배차, 단일 기사 최적화, 기초 견적 계산  \n- Basic Security: HTTPS, JWT 인증, CORS 설정  \n- Development Setup: GitHub Actions CI/CD, Vercel 배포 파이프라인  \n- Timeline: 8주\n\n### Phase 2: Feature Enhancement – ~M+4\n- Advanced Features: 제약조건 모델러 UI/JSON 스키마, 문서(PDF/Excel) 생성  \n- Performance Optimization: 경로 API 캐싱, 쿼리 튜닝  \n- Enhanced Security: OAuth2 연동, RBAC 기반 권한 관리  \n- Monitoring Implementation: Vercel Analytics, Supabase Logs 대시보드  \n- Timeline: 8주\n\n### Phase 3: Scaling & Optimization – ~M+6\n- Scalability Implementation: Supabase Auto-Scaling, Edge Function 분리  \n- Advanced Integrations: Mapbox GL 고급 기능, Tmap·Atlan 알고리즘 비교, 실시간 차량 위치 추적  \n- Enterprise Features: 관리자 대시보드(통계·알림), 다국어 지원  \n- Compliance & Auditing: GDPR·개인정보보호법 심층 검증  \n- Timeline: 8주\n- Compliance & Auditing: GDPR·개인정보보호법 심층 검증  \n- Timeline: 8주\n\n---\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- **Technology Risks**: Tmap 무료 호출 한도 초과  \n  ・Mitigation: TTL 기반 경로 캐시, 대체 무료 API 검토  \n- **Performance Risks**: 동시성 급증에 따른 응답 지연  \n  ・Mitigation: ISR & Edge Functions 분리, DB 인덱싱  \n- **Security Risks**: 인증·인가 취약점  \n  ・Mitigation: JWT 검증, OWASP Top10 대응, 정기 보안 점검  \n- **Integration Risks**: 외부 API 장애  \n  ・Mitigation: 서킷 브레이커, 재시도·백오프 정책\n\n### Project Delivery Risks\n- **Timeline Risks**: MVP 지연  \n  ・Contingency: 핵심 기능 우선 순위 재조정  \n- **Resource Risks**: Supabase 기능 미숙  \n  ・Contingency: 문서·커뮤니티 활용, 외부 컨설팅  \n- **Quality Risks**: 테스트 커버리지 부족  \n  ・Contingency: 유닛·통합 테스트 필수화, 코드 리뷰 강화  \n- **Deployment Risks**: 프로덕션 환경 차이  \n  ・Contingency: 스테이징·롤백 전략 수립  \n\n---\n\n> 본 TRD는 PRD 요구사항에 부합하는 최소 실현 가능 아키텍처와 기술 스택을 제시하며, 빠른 출시와 유지보수 용이성을 최우선으로 설계되었습니다.",
      "writedAt": "2025-07-28T15:30:33.351Z"
    },
    {
      "type": "guideline",
      "content": "# Ongoing Smart Logistics Platform: Code Guidelines\n\n## 1. Project Overview\n\nThe Ongoing Smart Logistics Platform is a Next.js-based responsive web application (PWA) leveraging Supabase for backend services. It focuses on optimizing delivery routes, modeling constraints, automating quotes and dispatch recommendations, and providing real-time vehicle tracking and an administrative dashboard. Key technologies include Next.js 15, React, Tailwind CSS, Supabase (PostgreSQL, Auth, Storage), Tmap API, Atlan API, PDFKit, ExcelJS, and Mapbox GL. The architecture utilizes ISR (Incremental Static Regeneration) and Server Actions for optimized rendering and efficient data fetching.\n\n## 2. Core Principles\n\n1.  **Readability and Maintainability:** Code MUST be easily understood and modified by any team member.\n2.  **Performance Optimization:** Prioritize efficient resource utilization and fast user experiences.\n3.  **Robustness and Reliability:** Implement comprehensive error handling and validation to ensure system stability.\n4.  **Security by Design:** Embed security considerations into every stage of development.\n5.  **Scalability and Extensibility:** Design modules to be independent and easily adaptable for future growth.\n\n## 3. Language-Specific Guidelines\n\n### Next.js (React, TypeScript)\n\n#### File Organization and Directory Structure\n\n*   **MUST:** Adhere to the Domain-Driven Organization Strategy as outlined in the TRD.\n    ```\n    /src\n    ├── domains/\n    │   ├── dispatch/          # Dispatch-related logic\n    │   │   ├── components/\n    │   │   ├── hooks/\n    │   │   ├── services/\n    │   │   ├── types/\n    │   │   └── utils/\n    │   ├── quote/             # Quote calculation and document generation\n    │   │   ├── components/\n    │   │   ├── forms/\n    │   │   ├── services/\n    │   │   └── types/\n    │   └── ... (other domains)\n    ├── components/            # Reusable UI components (domain-agnostic)\n    ├── libs/                  # API client wrappers, external service integrations\n    ├── pages/                 # Next.js page components\n    ├── styles/                # Tailwind configuration, global styles\n    └── utils/                 # Common utility functions (e.g., date formatting)\n    ```\n*   **MUST:** Place domain-specific components, hooks, services, types, and utilities within their respective domain folders.\n*   **MUST:** Place truly reusable, domain-agnostic UI components in `src/components`.\n*   **MUST NOT:** Create deeply nested, arbitrary subdirectories without clear logical grouping.\n\n#### Import/Dependency Management\n\n*   **MUST:** Use absolute imports for modules within the `src` directory. Configure `tsconfig.json` for path aliases.\n    ```typescript\n    // MUST: Absolute import for clarity and refactoring ease\n    import { calculateOptimalRoute } from '@/domains/dispatch/services/routeOptimizer';\n    import Button from '@/components/ui/Button';\n    ```\n    ```typescript\n    // MUST NOT: Relative import for modules outside the current domain or component tree\n    // This can lead to brittle paths and refactoring headaches\n    import { calculateOptimalRoute } from '../../../../domains/dispatch/services/routeOptimizer';\n    ```\n*   **MUST:** Group imports by type (e.g., React, external libraries, internal modules).\n    ```typescript\n    // MUST: Organized imports\n    import React from 'react';\n    import { useRouter } from 'next/router';\n    import { useQuery } from '@tanstack/react-query';\n\n    import { fetchUserData } from '@/domains/auth/services/userService';\n    import UserProfileCard from '@/components/user/UserProfileCard';\n    import { formatCurrency } from '@/utils/formatters';\n    ```\n\n#### Error Handling Patterns\n\n*   **MUST:** Use `try-catch` blocks for asynchronous operations that can fail (e.g., API calls, database operations).\n*   **MUST:** Return structured error objects or throw custom error classes for predictable error handling.\n    ```typescript\n    // MUST: Structured error handling in a service function\n    interface RouteOptimizationResult {\n        path: string[];\n        eta: number;\n    }\n\n    interface RouteOptimizationError {\n        code: string;\n        message: string;\n    }\n\n    async function getOptimizedRoute(params: any): Promise<RouteOptimizationResult | RouteOptimizationError> {\n        try {\n            const response = await fetch('/api/optimize-route', { method: 'POST', body: JSON.stringify(params) });\n            if (!response.ok) {\n                const errorData = await response.json();\n                return { code: 'API_ERROR', message: errorData.message || 'Failed to optimize route' };\n            }\n            const data = await response.json();\n            return { path: data.path, eta: data.eta };\n        } catch (error) {\n            console.error('Route optimization failed:', error);\n            return { code: 'NETWORK_ERROR', message: 'Network or unexpected error occurred.' };\n        }\n    }\n    ```\n*   **MUST:** Display user-friendly error messages in the UI.\n*   **MUST:** Log detailed errors to the console or a monitoring service (Vercel Analytics, Supabase Logs) for debugging.\n*   **MUST NOT:** Catch errors and silently fail without logging or user feedback.\n\n### Supabase (PostgreSQL, Edge Functions)\n\n#### Database Schema and Migrations\n\n*   **MUST:** Manage database schema changes using Supabase migrations.\n    ```sql\n    -- MUST: Example migration file (supabase/migrations/TIMESTAMP_create_delivery_routes_table.sql)\n    CREATE TABLE public.delivery_routes (\n        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n        driver_id UUID REFERENCES auth.users(id),\n        route_data JSONB NOT NULL,\n        optimized_at TIMESTAMPTZ DEFAULT NOW()\n    );\n    ```\n*   **MUST:** Use clear, descriptive names for tables, columns, and constraints.\n*   **MUST:** Define appropriate data types and constraints (e.g., `NOT NULL`, `FOREIGN KEY`).\n*   **MUST:** Add indexes to frequently queried columns to optimize performance.\n\n#### Edge Functions\n\n*   **MUST:** Implement Edge Functions for computationally intensive tasks like route optimization and quote calculation to leverage serverless scalability and reduce client-side load.\n*   **MUST:** Validate all incoming requests to Edge Functions.\n*   **MUST:** Use Supabase client libraries for secure database interactions within Edge Functions.\n    ```typescript\n    // MUST: Example Edge Function (supabase/functions/optimize-route/index.ts)\n    import { createClient } from '@supabase/supabase-js';\n    import { serve } from 'std/http';\n\n    serve(async (req) => {\n        const supabase = createClient(\n            Deno.env.get('SUPABASE_URL') ?? '',\n            Deno.env.get('SUPABASE_ANON_KEY') ?? ''\n        );\n\n        if (req.method !== 'POST') {\n            return new Response(JSON.stringify({ error: 'Method Not Allowed' }), { status: 405 });\n        }\n\n        try {\n            const { locations, constraints } = await req.json();\n            // Call external Tmap/Atlan API here\n            const optimizedRoute = { path: ['locA', 'locB'], eta: 120 }; // Placeholder\n            return new Response(JSON.stringify(optimizedRoute), {\n                headers: { 'Content-Type': 'application/json' },\n                status: 200,\n            });\n        } catch (error) {\n            console.error('Edge Function error:', error);\n            return new Response(JSON.stringify({ error: 'Internal Server Error', details: error.message }), { status: 500 });\n        }\n    });\n    ```\n\n## 4. Code Style Rules\n\n### MUST Follow:\n\n*   **Consistent Naming Conventions:**\n    *   **Variables/Functions:** `camelCase` (e.g., `userName`, `getOptimizedRoute`).\n    *   **Components:** `PascalCase` (e.g., `UserProfileCard`, `RouteOptimizerForm`).\n    *   **Constants:** `UPPER_SNAKE_CASE` (e.g., `MAX_RETRIES`, `API_KEY`).\n    *   **Types/Interfaces:** `PascalCase` (e.g., `interface UserProfile`, `type RouteData`).\n    *   **Files:** `kebab-case` for components and pages (e.g., `user-profile-card.tsx`, `dispatch-dashboard.tsx`), `camelCase` for utility and service files (e.g., `routeOptimizer.ts`, `formatters.ts`).\n    *   **Rationale:** Enhances readability and predictability, making it easier to identify the purpose of an identifier.\n\n*   **Explicit Typing (TypeScript):**\n    *   **MUST:** Explicitly type function parameters, return values, and complex object structures. Avoid `any` unless absolutely necessary and justified.\n    ```typescript\n    // MUST: Explicit typing\n    interface Location {\n        latitude: number;\n        longitude: number;\n        address: string;\n    }\n\n    function calculateDistance(loc1: Location, loc2: Location): number {\n        // ... calculation\n        return 100;\n    }\n    ```\n    ```typescript\n    // MUST NOT: Implicit any or vague typing\n    function calculateDistance(loc1: any, loc2: any) { // Type inference might be okay for simple cases, but explicit is better for complex objects\n        return 100;\n    }\n    ```\n    *   **Rationale:** Improves code clarity, enables static analysis, and reduces runtime errors.\n\n*   **Component Structure and Props:**\n    *   **MUST:** Define component props using TypeScript interfaces.\n    *   **MUST:** Destructure props at the beginning of the component function.\n    ```typescript\n    // MUST: Clear component props and destructuring\n    interface ButtonProps {\n        onClick: () => void;\n        label: string;\n        variant?: 'primary' | 'secondary';\n        isDisabled?: boolean;\n    }\n\n    const Button: React.FC<ButtonProps> = ({ onClick, label, variant = 'primary', isDisabled = false }) => {\n        return (\n            <button\n                onClick={onClick}\n                className={`btn ${variant}`}\n                disabled={isDisabled}\n            >\n                {label}\n            </button>\n        );\n    };\n    ```\n    *   **Rationale:** Enhances type safety, readability, and makes component usage clear.\n\n*   **Functional Components and Hooks:**\n    *   **MUST:** Prefer functional components over class components.\n    *   **MUST:** Use React Hooks (`useState`, `useEffect`, `useCallback`, `useMemo`, `useRef`, custom hooks) for managing state and side effects.\n    *   **MUST:** Create custom hooks to encapsulate reusable logic and stateful behavior.\n    ```typescript\n    // MUST: Custom hook for reusable logic\n    import { useState, useEffect } from 'react';\n\n    function useDebounce<T>(value: T, delay: number): T {\n        const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n        useEffect(() => {\n            const handler = setTimeout(() => {\n                setDebouncedValue(value);\n            }, delay);\n            return () => {\n                clearTimeout(handler);\n            };\n        }, [value, delay]);\n\n        return debouncedValue;\n    }\n    ```\n    *   **Rationale:** Promotes reusability, improves testability, and aligns with modern React practices.\n\n*   **Tailwind CSS Usage:**\n    *   **MUST:** Apply styles primarily using Tailwind utility classes directly in JSX.\n    *   **MUST:** Create custom components or use `@apply` in `globals.css` for complex, reusable styles that cannot be easily expressed with utility classes.\n    *   **Rationale:** Speeds up UI development and maintains consistency.\n\n### MUST NOT Do:\n\n*   **Avoid Excessive Nesting:**\n    *   **MUST NOT:** Create deeply nested folder structures without clear logical boundaries.\n    *   **MUST NOT:** Nest JSX elements excessively, leading to unreadable component trees.\n    *   **Rationale:** Reduces complexity and improves code readability.\n\n*   **Avoid Large, Monolithic Files:**\n    *   **MUST NOT:** Create single files that contain multiple unrelated components, services, or large amounts of business logic.\n    *   **Rationale:** Improves maintainability, testability, and allows for better code organization. Break down large files into smaller, focused modules.\n    ```typescript\n    // MUST NOT: Monolithic file (e.g., my-feature.ts)\n    // Contains multiple components, hooks, and services in one file.\n    // Break these into separate files within their domain or component folders.\n    // e.g., components/MyFeatureComponent.tsx, hooks/useMyFeatureData.ts, services/myFeatureService.ts\n    ```\n\n*   **Avoid Complex State Management Patterns (Initially):**\n    *   **MUST NOT:** Introduce complex global state management libraries (e.g., Redux, Zustand) unless a clear, proven need arises that cannot be met by React's built-in context API or simple `useState`/`useReducer`.\n    *   **Rationale:** Supabase provides robust data management capabilities, and Next.js Server Actions and React Query (or similar data fetching libraries) can handle most data fetching and caching needs. Over-engineering state management can introduce unnecessary complexity.\n    ```typescript\n    // MUST NOT: Unnecessary complex global state for simple shared data\n    // import { createStore } from 'zustand';\n    // const useGlobalCounter = createStore(...)\n    // For simple shared state, React Context API is often sufficient.\n    ```\n\n*   **Avoid Direct DOM Manipulation:**\n    *   **MUST NOT:** Directly manipulate the DOM using `document.getElementById` or similar methods. Use React's ref system when direct DOM access is unavoidable (e.g., integrating with third-party libraries).\n    *   **Rationale:** Violates React's declarative paradigm and can lead to unpredictable behavior.\n\n*   **Avoid Magic Strings/Numbers:**\n    *   **MUST NOT:** Use hardcoded strings or numbers for configuration, error messages, or critical values without defining them as constants.\n    *   **Rationale:** Improves maintainability, reduces errors, and facilitates internationalization.\n\n## 5. Architecture Patterns\n\n### Component/Module Structure Guidelines\n\n*   **MUST:** Design components to be single-responsibility and highly cohesive. A component should do one thing well.\n*   **MUST:** Separate presentation logic (components) from business logic (services, hooks).\n*   **MUST:** Use `props` for parent-to-child communication.\n*   **MUST:** Use callbacks or context for child-to-parent or cross-component communication.\n*   **MUST:** Leverage Next.js Server Components and Server Actions for data fetching and mutations where appropriate, minimizing client-side JavaScript.\n    ```typescript\n    // MUST: Server Action for data mutation\n    // app/actions.ts\n    'use server';\n\n    import { createClient } from '@/libs/supabase/server';\n\n    export async function createDeliveryRoute(formData: FormData) {\n        const supabase = createClient();\n        const routeData = {\n            origin: formData.get('origin'),\n            destination: formData.get('destination'),\n            // ... other fields\n        };\n\n        const { data, error } = await supabase.from('delivery_routes').insert([routeData]);\n\n        if (error) {\n            console.error('Error inserting route:', error.message);\n            return { success: false, message: error.message };\n        }\n        return { success: true, data };\n    }\n\n    // Usage in a Server Component\n    // <form action={createDeliveryRoute}>...</form>\n    ```\n\n### Data Flow Patterns\n\n*   **Client-Server Communication:**\n    *   **MUST:** Utilize Next.js API Routes for data fetching and mutations that require server-side logic or interaction with external APIs (Tmap, Atlan).\n    *   **MUST:** Use Server Actions for direct database interactions and mutations from Server Components.\n    *   **MUST:** Employ a data fetching library (e.g., React Query, SWR) on the client-side for efficient caching, revalidation, and error handling of API calls.\n    *   **Rationale:** Optimizes data fetching, reduces boilerplate, and improves user experience.\n\n*   **Database Interaction:**\n    *   **MUST:** Use the Supabase JS client library for all database operations.\n    *   **MUST:** Implement row-level security (RLS) policies in Supabase for granular access control.\n    *   **MUST:** Use transactions for operations that require atomicity.\n    ```typescript\n    // MUST: Supabase transaction for atomic operations\n    import { createClient } from '@supabase/supabase-js';\n\n    async function processOrder(orderId: string, userId: string) {\n        const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!); // Use service role key for server-side\n\n        const { data: order, error: orderError } = await supabase\n            .from('orders')\n            .select('*')\n            .eq('id', orderId)\n            .single();\n\n        if (orderError || !order) throw new Error('Order not found');\n\n        // Start transaction (conceptual for Supabase, often handled by service layer or Edge Function)\n        // In Supabase, this might involve a stored procedure or multiple sequential operations with error checks.\n        const { error: updateError } = await supabase\n            .from('orders')\n            .update({ status: 'processed' })\n            .eq('id', orderId);\n\n        if (updateError) throw new Error('Failed to update order status');\n\n        const { error: logError } = await supabase\n            .from('order_logs')\n            .insert([{ order_id: orderId, user_id: userId, event: 'Order Processed' }]);\n\n        if (logError) throw new Error('Failed to log order event');\n\n        return { success: true };\n    }\n    ```\n\n### State Management Conventions\n\n*   **MUST:** Prefer local component state (`useState`, `useReducer`) for UI-specific state.\n*   **MUST:** Use React Context API for sharing moderately complex state across a subtree of components (e.g., theme, user preferences, authentication status).\n*   **MUST:** Use data fetching libraries (React Query/SWR) for managing server-side data and its caching.\n*   **MUST NOT:** Create global state that replicates or duplicates server-side data which should be managed by a data fetching library.\n\n### API Design Standards\n\n*   **MUST:** Design RESTful API routes with clear, descriptive endpoints.\n    *   `GET /api/routes`\n    *   `GET /api/routes/[id]`\n    *   `POST /api/routes`\n    *   `PUT /api/routes/[id]`\n    *   `DELETE /api/routes/[id]`\n*   **MUST:** Use appropriate HTTP status codes for responses (e.g., 200 OK, 201 Created, 400 Bad Request, 401 Unauthorized, 404 Not Found, 500 Internal Server Error).\n*   **MUST:** Return consistent JSON response formats for both success and error cases.\n    ```json\n    // MUST: Consistent success response\n    {\n        \"success\": true,\n        \"data\": {\n            \"id\": \"uuid-123\",\n            \"eta\": 120,\n            \"path\": [\"locA\", \"locB\"]\n        }\n    }\n\n    // MUST: Consistent error response\n    {\n        \"success\": false,\n        \"error\": {\n            \"code\": \"VALIDATION_ERROR\",\n            \"message\": \"Invalid input parameters\",\n            \"details\": {\n                \"field\": \"locations\",\n                \"reason\": \"Must provide at least two locations\"\n            }\n        }\n    }\n    ```\n*   **MUST:** Implement input validation on both client and server sides.\n*   **MUST:** Secure API endpoints using JWT tokens and Supabase Auth.\n*   **MUST:** Implement rate limiting for external API calls (Tmap, Atlan) to prevent exceeding quotas.",
      "writedAt": "2025-07-28T15:30:33.351Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-28T15:30:33.351Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-28T15:30:33.351Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-28T15:30:33.351Z"
    }
  ]
}